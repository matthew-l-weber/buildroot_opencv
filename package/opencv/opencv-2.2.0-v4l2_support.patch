--- a/modules/highgui/src/cap_v4l.cpp	2011-11-03 08:37:15.000000000 -0500
+++ b/modules/highgui/src/cap_v4l.cpp	2011-11-10 07:25:27.000000000 -0600
@@ -214,8 +214,6 @@
 #include <sys/types.h>
 #include <sys/mman.h>
 
-#include <linux/videodev.h>
-
 #include <string.h>
 #include <stdlib.h>
 #include <asm/types.h>          /* for videodev2.h */
@@ -223,9 +221,7 @@
 #include <sys/stat.h>
 #include <sys/ioctl.h>
 
-#ifdef HAVE_CAMV4L2
 #include <linux/videodev2.h>
-#endif
 
 /* Defaults - If your board can do better, set it here.  Set for the most common type inputs. */
 #define DEFAULT_V4L_WIDTH  640
@@ -235,9 +231,10 @@
 #define MAX_CAMERAS 8
 
 
-// default and maximum number of V4L buffers, not including last, 'special' buffer
-#define MAX_V4L_BUFFERS 10
-#define DEFAULT_V4L_BUFFERS 4
+// default and maximum number of V4L buffers
+// (cls) these values were set to 1 to put the omap3isp into snapshot mode
+#define MAX_V4L_BUFFERS 1
+#define DEFAULT_V4L_BUFFERS 1
 
 // if enabled, then bad JPEG warnings become errors and cause NULL returned instead of image
 #define V4L_ABORT_BADJPEG
@@ -246,8 +243,6 @@
 
 /* Device Capture Objects */
 
-#ifdef HAVE_CAMV4L2
-
 /* V4L2 structure */
 struct buffer
 {
@@ -269,8 +264,6 @@
 #define V4L2_PIX_FMT_SGBRG v4l2_fourcc('G','B','R','G') /* bayer GBRG   GBGB.. RGRG.. */
 #endif
 
-#endif  /* HAVE_CAMV4L2 */
-
 enum PALETTE_TYPE {
   PALETTE_BGR24 = 1,
   PALETTE_YVU420,
@@ -280,7 +273,9 @@
   PALETTE_SBGGR8,
   PALETTE_SN9C10X,
   PALETTE_MJPEG,
-  PALETTE_SGBRG
+  PALETTE_SGBRG,
+  PALETTE_SGRBG12,
+  PALETTE_Y12
 };
 
 typedef struct CvCaptureCAM_V4L
@@ -288,18 +283,11 @@
     int deviceHandle;
     int bufferIndex;
     int FirstCapture;
-    struct video_capability capability;
-    struct video_window     captureWindow;
-    struct video_picture    imageProperties;
-    struct video_mbuf       memoryBuffer;
-    struct video_mmap       *mmaps;
-    char *memoryMap;
     IplImage frame;
 
-#ifdef HAVE_CAMV4L2
    enum PALETTE_TYPE palette;
    /* V4L2 variables */
-   buffer buffers[MAX_V4L_BUFFERS + 1];
+   buffer buffers[MAX_V4L_BUFFERS];
    struct v4l2_capability cap;
    struct v4l2_input inp;
    struct v4l2_format form;
@@ -319,17 +307,9 @@
    int v4l2_gain, v4l2_gain_min, v4l2_gain_max;
    int v4l2_exposure, v4l2_exposure_min, v4l2_exposure_max;
 
-#endif /* HAVE_CAMV4L2 */
-
 }
 CvCaptureCAM_V4L;
 
-#ifdef HAVE_CAMV4L2
-
-int V4L2_SUPPORT = 0;
-
-#endif /* HAVE_CAMV4L2 */
-
 static void icvCloseCAM_V4L( CvCaptureCAM_V4L* capture );
 
 static int icvGrabFrameCAM_V4L( CvCaptureCAM_V4L* capture );
@@ -345,8 +325,6 @@
 static int numCameras = 0;
 static int indexList = 0;
 
-#ifdef HAVE_CAMV4L2
-
 // IOCTL handling for V4L2
 static int xioctl( int fd, int request, void *arg)
 {
@@ -361,8 +339,6 @@
 
 }
 
-#endif /* HAVE_CAMV4L2 */
-
 /* Simple test program: Find number of Video Sources available.
    Start from 0 and go to MAX_CAMERAS while checking for the device with that name.
    If it fails on the first attempt of /dev/video0, then check if /dev/video is valid.
@@ -393,91 +369,29 @@
 
 }; /* End icvInitCapture_V4L */
 
-static int
-try_palette(int fd,
-            struct video_picture *cam_pic,
-            int pal,
-            int depth)
-{
-  cam_pic->palette = pal;
-  cam_pic->depth = depth;
-  if (ioctl(fd, VIDIOCSPICT, cam_pic) < 0)
-    return 0;
-  if (ioctl(fd, VIDIOCGPICT, cam_pic) < 0)
-    return 0;
-  if (cam_pic->palette == pal)
-    return 1;
-  return 0;
-}
-
-#ifdef HAVE_CAMV4L2
-
 static int try_palette_v4l2(CvCaptureCAM_V4L* capture, unsigned long colorspace)
 {
+  int ret;
+  
   CLEAR (capture->form);
-
   capture->form.type                = V4L2_BUF_TYPE_VIDEO_CAPTURE;
   capture->form.fmt.pix.pixelformat = colorspace;
   capture->form.fmt.pix.field       = V4L2_FIELD_ANY;
   capture->form.fmt.pix.width = DEFAULT_V4L_WIDTH;
   capture->form.fmt.pix.height = DEFAULT_V4L_HEIGHT;
 
-  if (-1 == xioctl (capture->deviceHandle, VIDIOC_S_FMT, &capture->form))
+  ret = xioctl (capture->deviceHandle, VIDIOC_TRY_FMT, &capture->form);
+  if (ret < 0)
       return -1;
 
-
   if (colorspace != capture->form.fmt.pix.pixelformat)
+  {
     return -1;
+  }
   else
     return 0;
 }
 
-#endif /* HAVE_CAMV4L2 */
-
-static int try_init_v4l(CvCaptureCAM_V4L* capture, char *deviceName)
-{
-
-  // if detect = -1 then unable to open device
-  // if detect = 0 then detected nothing
-  // if detect = 1 then V4L device
-  int detect = 0;
-
-
-  // Test device for V4L compability
-
-  /* Test using an open to see if this new device name really does exists. */
-  /* No matter what the name - it still must be opened! */
-  capture->deviceHandle = open(deviceName, O_RDWR);
-
-
-  if (capture->deviceHandle == 0)
-  {
-    detect = -1;
-
-    icvCloseCAM_V4L(capture);
-  }
-
-  if (detect == 0)
-  {
-    /* Query the newly opened device for its capabilities */
-    if (ioctl(capture->deviceHandle, VIDIOCGCAP, &capture->capability) < 0)
-    {
-      detect = 0;
-
-      icvCloseCAM_V4L(capture);
-    }
-      else
-    {
-      detect = 1;
-    }
-  }
-
-  return detect;
-
-}
-
-#ifdef HAVE_CAMV4L2
-
 static int try_init_v4l2(CvCaptureCAM_V4L* capture, char *deviceName)
 {
 
@@ -512,14 +426,7 @@
     }
       else
     {
-      CLEAR (capture->capability);
-      capture->capability.type = capture->cap.capabilities;
-
-      /* Query channels number */
-      if (-1 != xioctl (capture->deviceHandle, VIDIOC_G_INPUT, &capture->capability.channels))
-      {
-        detect = 1;
-      }
+      detect = 1;
     }
   }
 
@@ -529,105 +436,84 @@
 
 static int autosetup_capture_mode_v4l2(CvCaptureCAM_V4L* capture)
 {
-  if (try_palette_v4l2(capture, V4L2_PIX_FMT_BGR24) == 0)
-  {
-    capture->palette = PALETTE_BGR24;
-  }
-  else
-  if (try_palette_v4l2(capture, V4L2_PIX_FMT_YVU420) == 0)
-  {
-    capture->palette = PALETTE_YVU420;
-  }
-  else
-  if (try_palette_v4l2(capture, V4L2_PIX_FMT_YUV411P) == 0)
-  {
-    capture->palette = PALETTE_YUV411P;
-  }
-  else
-
-#ifdef HAVE_JPEG
-#ifdef __USE_GNU
-      /* support for MJPEG is only available with libjpeg and gcc,
-	 because it's use libjepg and fmemopen()
-      */
-  if (try_palette_v4l2(capture, V4L2_PIX_FMT_MJPEG) == 0 ||
-      try_palette_v4l2(capture, V4L2_PIX_FMT_JPEG) == 0)
-  {
-    capture->palette = PALETTE_MJPEG;
-  }
-  else
-#endif
-#endif
-
-  if (try_palette_v4l2(capture, V4L2_PIX_FMT_YUYV) == 0)
-  {
-    capture->palette = PALETTE_YUYV;
-  }
-  else if (try_palette_v4l2(capture, V4L2_PIX_FMT_UYVY) == 0)
-  {
-    capture->palette = PALETTE_UYVY;
-  }
-  else
-  if (try_palette_v4l2(capture, V4L2_PIX_FMT_SN9C10X) == 0)
-  {
-    capture->palette = PALETTE_SN9C10X;
-  } else
-  if (try_palette_v4l2(capture, V4L2_PIX_FMT_SBGGR8) == 0)
-  {
-    capture->palette = PALETTE_SBGGR8;
-  } else
-  if (try_palette_v4l2(capture, V4L2_PIX_FMT_SGBRG) == 0)
-  {
-    capture->palette = PALETTE_SGBRG;
-  }
-      else
-  {
-	fprintf(stderr, "HIGHGUI ERROR: V4L2: Pixel format of incoming image is unsupported by OpenCV\n");
-    icvCloseCAM_V4L(capture);
-    return -1;
-  }
-
-  return 0;
-
-}
-
-#endif /* HAVE_CAMV4L2 */
-
-static int autosetup_capture_mode_v4l(CvCaptureCAM_V4L* capture)
-{
-
-  if(ioctl(capture->deviceHandle, VIDIOCGPICT, &capture->imageProperties) < 0) {
-     fprintf( stderr, "HIGHGUI ERROR: V4L: Unable to determine size of incoming image\n");
-     icvCloseCAM_V4L(capture);
-     return -1;
-  }
-
-  /* Yet MORE things that might have to be changes with your frame capture card */
-  /* This sets the scale to the center of a 2^16 number */
-  if (try_palette(capture->deviceHandle, &capture->imageProperties, VIDEO_PALETTE_RGB24, 24)) {
-      //printf("negotiated palette RGB24\n");
-  }
-  else if (try_palette(capture->deviceHandle, &capture->imageProperties, VIDEO_PALETTE_YUV420P, 16)) {
-      //printf("negotiated palette YUV420P\n");
-  }
-  else if (try_palette(capture->deviceHandle, &capture->imageProperties, VIDEO_PALETTE_YUV420, 16)) {
-      //printf("negotiated palette YUV420\n");
-  }
-  else if (try_palette(capture->deviceHandle, &capture->imageProperties, VIDEO_PALETTE_YUV411P, 16)) {
-      //printf("negotiated palette YUV420P\n");
-  }
-  else {
-	fprintf(stderr, "HIGHGUI ERROR: V4L: Pixel format of incoming image is unsupported by OpenCV\n");
-    icvCloseCAM_V4L(capture);
-    return -1;
-  }
-
-  return 0;
-
+   /* Commented out formats cause a warning in the isp driver because
+    * they are not allowed formats.  They are being commented out for now
+    * with the hope that a fix will be found for the isp driver to remedy this situation.
+    * Problem is in ispvideo.c on line 218 in function isp_video_pix_to_mbus.
+    */
+//   if (try_palette_v4l2(capture, V4L2_PIX_FMT_BGR24) == 0)
+//   {
+//      capture->palette = PALETTE_BGR24;
+//   }
+//   else
+//   if (try_palette_v4l2(capture, V4L2_PIX_FMT_YVU420) == 0)
+//   {
+//      capture->palette = PALETTE_YVU420;
+//   }
+//   else
+//   if (try_palette_v4l2(capture, V4L2_PIX_FMT_YUV411P) == 0)
+//   {
+//      capture->palette = PALETTE_YUV411P;
+//   }
+//   else
+//   
+//#ifdef HAVE_JPEG
+//#ifdef __USE_GNU
+//   /* support for MJPEG is only available with libjpeg and gcc,
+//    because it's use libjepg and fmemopen()
+//   */
+//   if (try_palette_v4l2(capture, V4L2_PIX_FMT_MJPEG) == 0 ||
+//      try_palette_v4l2(capture, V4L2_PIX_FMT_JPEG) == 0)
+//   {
+//      capture->palette = PALETTE_MJPEG;
+//   }
+//   else
+//#endif
+//#endif
+   
+   if (try_palette_v4l2(capture, V4L2_PIX_FMT_YUYV) == 0)
+   {
+      capture->palette = PALETTE_YUYV;
+   }
+   else 
+   if (try_palette_v4l2(capture, V4L2_PIX_FMT_UYVY) == 0)
+   {
+      capture->palette = PALETTE_UYVY;
+   }
+   else
+//   if (try_palette_v4l2(capture, V4L2_PIX_FMT_SN9C10X) == 0)
+//   {
+//      capture->palette = PALETTE_SN9C10X;
+//   } 
+//   else
+   if (try_palette_v4l2(capture, V4L2_PIX_FMT_SBGGR8) == 0)
+   {
+      capture->palette = PALETTE_SBGGR8;
+   } 
+   else
+   if (try_palette_v4l2(capture, V4L2_PIX_FMT_SGBRG) == 0)
+   {
+      capture->palette = PALETTE_SGBRG;
+   }
+   else
+   if (try_palette_v4l2(capture, V4L2_PIX_FMT_SGRBG12) == 0)
+   {
+      capture->palette = PALETTE_SGRBG12;
+   }
+   else
+   if (try_palette_v4l2(capture, V4L2_PIX_FMT_Y12) == 0)
+   {
+      capture->palette = PALETTE_Y12;
+   }
+   else
+   {
+      fprintf(stderr, "HIGHGUI ERROR: V4L2: Pixel format of incoming image is unsupported by OpenCV\n");
+      icvCloseCAM_V4L(capture);
+      return -1;
+   }
+   return 0;
 }
 
-#ifdef HAVE_CAMV4L2
-
 static void v4l2_scan_controls_enumerate_menu(CvCaptureCAM_V4L* capture)
 {
 //  printf (" Menu items:\n");
@@ -807,9 +693,6 @@
        return -1;
    }
 
-   /* starting from here, we assume we are in V4L2 mode */
-   V4L2_SUPPORT = 1;
-
    /* Init V4L2 control variables */
    capture->v4l2_brightness = 0;
    capture->v4l2_contrast = 0;
@@ -866,21 +749,9 @@
    CLEAR (capture->form);
    capture->form.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
 
-   if (-1 == xioctl (capture->deviceHandle, VIDIOC_G_FMT, &capture->form)) {
-       fprintf( stderr, "HIGHGUI ERROR: V4L2: Could not obtain specifics of capture window.\n\n");
-       icvCloseCAM_V4L(capture);
-       return -1;
-   }
-
-   if (V4L2_SUPPORT == 0)
-   {
-   }
-
    if (autosetup_capture_mode_v4l2(capture) == -1)
        return -1;
 
-   icvSetVideoSize(capture, DEFAULT_V4L_WIDTH, DEFAULT_V4L_HEIGHT);
-
    unsigned int min;
 
    /* Buggy driver paranoia. */
@@ -894,6 +765,15 @@
    if (capture->form.fmt.pix.sizeimage < min)
        capture->form.fmt.pix.sizeimage = min;
 
+   /* Need to set the format now that a valid format has been found in order to 
+    * correctly set the sizeimage.
+    */
+   if (-1 == xioctl (capture->deviceHandle, VIDIOC_S_FMT, &capture->form)) {
+       fprintf( stderr, "HIGHGUI ERROR: V4L2: Could not set specifics of capture window.\n\n");
+       icvCloseCAM_V4L(capture);
+       return -1;
+   }
+
    CLEAR (capture->req);
 
    unsigned int buffer_number = DEFAULT_V4L_BUFFERS;
@@ -968,142 +848,51 @@
            return -1;
        }
 
-       if (n_buffers == 0) {
-	 capture->buffers[MAX_V4L_BUFFERS].start = malloc( buf.length );
-	 capture->buffers[MAX_V4L_BUFFERS].length = buf.length;
-       }
    }
 
    /* Set up Image data */
-   cvInitImageHeader( &capture->frame,
-                      cvSize( capture->captureWindow.width,
-                              capture->captureWindow.height ),
-                      IPL_DEPTH_8U, 3, IPL_ORIGIN_TL, 4 );
-   /* Allocate space for RGBA data */
-   capture->frame.imageData = (char *)cvAlloc(capture->frame.imageSize);
-
-   return 1;
-}; /* End _capture_V4L2 */
-
-#endif /* HAVE_CAMV4L2 */
-
-static int _capture_V4L (CvCaptureCAM_V4L *capture, char *deviceName)
-{
-   int detect_v4l = 0;
-
-   detect_v4l = try_init_v4l(capture, deviceName);
-
-   if ((detect_v4l == -1)
-       )
-   {
-     fprintf (stderr, "HIGHGUI ERROR: V4L"
-              ": device %s: Unable to open for READ ONLY\n", deviceName);
-
-     return -1;
-   }
-
-   if ((detect_v4l <= 0)
-       )
-   {
-     fprintf (stderr, "HIGHGUI ERROR: V4L"
-              ": device %s: Unable to query number of channels\n", deviceName);
-
-     return -1;
-   }
-
-   {
-     if ((capture->capability.type & VID_TYPE_CAPTURE) == 0) {
-       /* Nope. */
-       fprintf( stderr, "HIGHGUI ERROR: V4L: "
-                "device %s is unable to capture video memory.\n",deviceName);
-       icvCloseCAM_V4L(capture);
-       return -1;
-     }
-
-   }
-
-
-   /* The following code sets the CHANNEL_NUMBER of the video input.  Some video sources
-   have sub "Channel Numbers".  For a typical V4L TV capture card, this is usually 1.
-   I myself am using a simple NTSC video input capture card that uses the value of 1.
-   If you are not in North America or have a different video standard, you WILL have to change
-   the following settings and recompile/reinstall.  This set of settings is based on
-   the most commonly encountered input video source types (like my bttv card) */
-
-   {
-
-     if(capture->capability.channels>0) {
-
-       struct video_channel selectedChannel;
-       memset(&selectedChannel, 0, sizeof(selectedChannel));
-
-       selectedChannel.channel=CHANNEL_NUMBER;
-       if (ioctl(capture->deviceHandle, VIDIOCGCHAN , &selectedChannel) != -1) {
-          /* set the video mode to ( VIDEO_MODE_PAL, VIDEO_MODE_NTSC, VIDEO_MODE_SECAM) */
-//           selectedChannel.norm = VIDEO_MODE_NTSC;
-          if (ioctl(capture->deviceHandle, VIDIOCSCHAN , &selectedChannel) == -1) {
-             /* Could not set selected channel - Oh well */
-             //printf("\n%d, %s not NTSC capable.\n",selectedChannel.channel, selectedChannel.name);
-          } /* End if */
-       } /* End if */
-     } /* End if */
-
-   }
-
-   {
-
-     if(ioctl(capture->deviceHandle, VIDIOCGWIN, &capture->captureWindow) == -1) {
-       fprintf( stderr, "HIGHGUI ERROR: V4L: "
-                "Could not obtain specifics of capture window.\n\n");
-       icvCloseCAM_V4L(capture);
-       return -1;
-     }
-
-   }
-
-   {
-
-     if (autosetup_capture_mode_v4l(capture) == -1)
-       return -1;
-
-   }
-
+   switch(capture->palette)
    {
-
-     ioctl(capture->deviceHandle, VIDIOCGMBUF, &capture->memoryBuffer);
-     capture->memoryMap  = (char *)mmap(0,
-                                   capture->memoryBuffer.size,
-                                   PROT_READ | PROT_WRITE,
-                                   MAP_SHARED,
-                                   capture->deviceHandle,
-                                   0);
-     if (capture->memoryMap == MAP_FAILED) {
-        fprintf( stderr, "HIGHGUI ERROR: V4L: Mapping Memmory from video source error: %s\n", strerror(errno));
-        icvCloseCAM_V4L(capture);
-     }
-
-     /* Set up video_mmap structure pointing to this memory mapped area so each image may be
-        retrieved from an index value */
-     capture->mmaps = (struct video_mmap *)
-                 (malloc(capture->memoryBuffer.frames * sizeof(struct video_mmap)));
-     if (!capture->mmaps) {
-        fprintf( stderr, "HIGHGUI ERROR: V4L: Could not memory map video frames.\n");
-        icvCloseCAM_V4L(capture);
-        return -1;
-     }
-
+      case PALETTE_BGR24:
+      case PALETTE_YVU420:
+      case PALETTE_YUV411P:
+      case PALETTE_YUYV:
+      case PALETTE_UYVY:
+      case PALETTE_SBGGR8:
+      case PALETTE_SN9C10X:
+      case PALETTE_MJPEG:
+      case PALETTE_SGBRG:
+         cvInitImageHeader( &capture->frame,
+                  cvSize( capture->form.fmt.pix.width,
+                          capture->form.fmt.pix.height ),
+                  IPL_DEPTH_8U, 3, IPL_ORIGIN_TL, 4 );
+         /* Allocate space for RGBA data */
+         capture->frame.imageData = (char *)cvAlloc(capture->frame.imageSize);
+         break;
+      case PALETTE_SGRBG12:
+         cvInitImageHeader( &capture->frame,
+                  cvSize( capture->form.fmt.pix.width,
+                          capture->form.fmt.pix.height ),
+                  IPL_DEPTH_16U, 3, IPL_ORIGIN_TL, 4 );
+         /* Allocate space for RGBA data */
+         capture->frame.imageData = (char *)cvAlloc(capture->frame.imageSize);
+         break;
+      case PALETTE_Y12:
+         cvInitImageHeader( &capture->frame,
+                  cvSize( capture->form.fmt.pix.width,
+                          capture->form.fmt.pix.height ),
+                  IPL_DEPTH_16U, 1, IPL_ORIGIN_TL, 4 );
+         /* Allocate space for 16 bit Y data */
+         capture->frame.imageData = (char *)cvAlloc(capture->frame.imageSize);
+         break;
+      default:
+         fprintf(stderr, "HIGHGUI ERROR: V4L2: invalid capture format.\n");
+         return -1; // Return an invalid pointer
+         break;
    }
 
-   /* Set up Image data */
-   cvInitImageHeader( &capture->frame,
-                      cvSize( capture->captureWindow.width,
-                              capture->captureWindow.height ),
-                      IPL_DEPTH_8U, 3, IPL_ORIGIN_TL, 4 );
-   /* Allocate space for RGBA data */
-   capture->frame.imageData = (char *)cvAlloc(capture->frame.imageSize);
-
    return 1;
-}; /* End _capture_V4L */
+}; /* End _capture_V4L2 */
 
 static CvCaptureCAM_V4L * icvCaptureFromCAM_V4L (int index)
 {
@@ -1149,26 +938,14 @@
       the standard set of cv calls promoting transparency.  "Vector Table" insertion. */
    capture->FirstCapture = 1;
 
-#ifdef HAVE_CAMV4L2
    if (_capture_V4L2 (capture, deviceName) == -1) {
        icvCloseCAM_V4L(capture);
-       V4L2_SUPPORT = 0;
-#endif  /* HAVE_CAMV4L2 */
-       if (_capture_V4L (capture, deviceName) == -1) {
-           icvCloseCAM_V4L(capture);
-           return NULL;
-       }
-#ifdef HAVE_CAMV4L2
-   } else {
-       V4L2_SUPPORT = 1;
+       return NULL;
    }
-#endif  /* HAVE_CAMV4L2 */
 
    return capture;
 }; /* End icvOpenCAM_V4L */
 
-#ifdef HAVE_CAMV4L2
-
 static int read_frame_v4l2(CvCaptureCAM_V4L* capture) {
     struct v4l2_buffer buf;
 
@@ -1201,12 +978,7 @@
 
    assert(buf.index < capture->req.count);
 
-   memcpy(capture->buffers[MAX_V4L_BUFFERS].start,
-	  capture->buffers[buf.index].start,
-	  capture->buffers[MAX_V4L_BUFFERS].length );
-   capture->bufferIndex = MAX_V4L_BUFFERS;
-   //printf("got data in buff %d, len=%d, flags=0x%X, seq=%d, used=%d)\n",
-   //	  buf.index, buf.length, buf.flags, buf.sequence, buf.bytesused);
+   capture->bufferIndex = buf.index;
 
    if (-1 == xioctl (capture->deviceHandle, VIDIOC_QBUF, &buf))
        perror ("VIDIOC_QBUF");
@@ -1229,8 +1001,10 @@
             FD_SET (capture->deviceHandle, &fds);
 
             /* Timeout. */
+            // (cls) Increased the timeout to 2.5 seconds to account for the max
+            //       exposure time of 2 sec.
             tv.tv_sec = 2;
-            tv.tv_usec = 0;
+            tv.tv_usec = 500000;
 
             r = select (capture->deviceHandle+1, &fds, NULL, NULL, &tv);
 
@@ -1242,7 +1016,7 @@
             }
 
             if (0 == r) {
-                fprintf (stderr, "select timeout\n");
+                fprintf (stderr, "HIGHGUI ERROR: V4L2: Capture timeout\n");
 
                 /* end the infinite loop */
                 break;
@@ -1254,8 +1028,6 @@
     }
 }
 
-#endif /* HAVE_CAMV4L2 */
-
 static int icvGrabFrameCAM_V4L(CvCaptureCAM_V4L* capture) {
 
    if (capture->FirstCapture) {
@@ -1264,11 +1036,6 @@
       /* This is just a technicality, but all buffers must be filled up before any
          staggered SYNC is applied.  SO, filler up. (see V4L HowTo) */
 
-#ifdef HAVE_CAMV4L2
-
-      if (V4L2_SUPPORT == 1)
-      {
-
         for (capture->bufferIndex = 0;
              capture->bufferIndex < ((int)capture->req.count);
              ++capture->bufferIndex)
@@ -1296,69 +1063,12 @@
             perror ("VIDIOC_STREAMON");
             return 0;
         }
-      } else
-#endif /* HAVE_CAMV4L2 */
-      {
-
-        for (capture->bufferIndex = 0;
-         capture->bufferIndex < (capture->memoryBuffer.frames-1);
-         ++capture->bufferIndex) {
-
-          capture->mmaps[capture->bufferIndex].frame  = capture->bufferIndex;
-          capture->mmaps[capture->bufferIndex].width  = capture->captureWindow.width;
-          capture->mmaps[capture->bufferIndex].height = capture->captureWindow.height;
-          capture->mmaps[capture->bufferIndex].format = capture->imageProperties.palette;
-
-          if (ioctl(capture->deviceHandle, VIDIOCMCAPTURE, &capture->mmaps[capture->bufferIndex]) == -1) {
-            fprintf( stderr, "HIGHGUI ERROR: V4L: Initial Capture Error: Unable to load initial memory buffers.\n");
-            return 0;
-          }
-        }
-
-      }
-
-#if defined(V4L_ABORT_BADJPEG) && defined(HAVE_CAMV4L2)
-     if (V4L2_SUPPORT == 1)
-     {
-        // skip first frame. it is often bad -- this is unnotied in traditional apps,
-        //  but could be fatal if bad jpeg is enabled
-        mainloop_v4l2(capture);
-     }
-#endif
 
       /* preparation is ok */
       capture->FirstCapture = 0;
    }
 
-#ifdef HAVE_CAMV4L2
-
-   if (V4L2_SUPPORT == 1)
-   {
-
-     mainloop_v4l2(capture);
-
-   } else
-#endif /* HAVE_CAMV4L2 */
-   {
-
-     capture->mmaps[capture->bufferIndex].frame  = capture->bufferIndex;
-     capture->mmaps[capture->bufferIndex].width  = capture->captureWindow.width;
-     capture->mmaps[capture->bufferIndex].height = capture->captureWindow.height;
-     capture->mmaps[capture->bufferIndex].format = capture->imageProperties.palette;
-
-     if (ioctl (capture->deviceHandle, VIDIOCMCAPTURE,
-		&capture->mmaps[capture->bufferIndex]) == -1) {
-	 /* capture is on the way, so just exit */
-	 return 1;
-     }
-
-     ++capture->bufferIndex;
-     if (capture->bufferIndex == capture->memoryBuffer.frames) {
-        capture->bufferIndex = 0;
-     }
-
-   }
-
+   mainloop_v4l2(capture);
    return(1);
 }
 
@@ -1898,16 +1608,123 @@
 }
 
 
-#define CLAMP(x)        ((x)<0?0:((x)>255)?255:(x))
-
-typedef struct {
-  int is_abs;
-  int len;
-  int val;
-} code_table_t;
-
-
-/* local storage */
+// SGRGB to RGB24
+// Copied from sgbrg2rgb24 with some modifications
+void sgrbg12_to_rgb48(long int WIDTH, long int HEIGHT, unsigned char *src, unsigned char *dst)
+{
+   unsigned long int i;
+   unsigned short *rawpt;
+   unsigned short *scanpt;
+   unsigned long int size;
+   
+   rawpt = (unsigned short *)src;
+   scanpt = (unsigned short *)dst;
+   size = WIDTH*HEIGHT;
+   
+   for ( i = 0; i < size; i++ )
+   {
+      if ( (i/WIDTH) % 2 == 0 ) //even row
+      {
+         if ( (i % 2) == 0 ) //even pixel - Green
+         {
+            if ( (i > WIDTH) && ((i % WIDTH) > 0) )
+            {
+               *scanpt++ = (((*(rawpt-WIDTH) + *(rawpt+WIDTH))/2)<<4); /* B */
+               *scanpt++ = ((*(rawpt))<<4);                        /* G */
+               *scanpt++ = (((*(rawpt-1)+*(rawpt+1))/2)<<4);       /* R */
+            } else
+            {
+               /* first line or left column */
+      
+               *scanpt++ = ((*(rawpt+WIDTH))<<4);      /* B */
+               *scanpt++ = ((*(rawpt))<<4);             /* G */
+               *scanpt++ = ((*(rawpt+1))<<4);           /* R */
+            }
+         } else //odd pixel - Red
+         {
+            if ( (i > WIDTH) && ((i % WIDTH) < (WIDTH-1)) )
+            {
+               *scanpt++ = (((*(rawpt-WIDTH-1) + *(rawpt-WIDTH+1) + *(rawpt+WIDTH-1) + *(rawpt+WIDTH+1))/4)<<4);      /* B */
+               *scanpt++ = (((*(rawpt-1)+*(rawpt+1)+*(rawpt-WIDTH)+*(rawpt+WIDTH))/4)<<4); /* G */
+               *scanpt++ = ((*(rawpt))<<4);       /* R */
+            } else
+            {
+               /* first line or right column */
+      
+               *scanpt++ = ((*(rawpt+WIDTH-1))<<4);      /* B */
+               *scanpt++ = (((*(rawpt-1)+*(rawpt+WIDTH))/2)<<4); /* G */
+               *scanpt++ = ((*(rawpt))<<4);       /* R */
+            }
+         }
+      } else
+      { //odd row
+         if ( (i % 2) == 0 ) //even pixel - Blue
+         {
+            if ( (i < (WIDTH*(HEIGHT-1))) && ((i % WIDTH) > 0) )
+            {
+               *scanpt++ = ((*(rawpt))<<4); /* B */
+               *scanpt++ = (((*(rawpt-1)+*(rawpt+1)+*(rawpt-WIDTH)+*(rawpt+WIDTH))/4)<<4);      /* G */
+               *scanpt++ = (((*(rawpt-WIDTH-1)+*(rawpt-WIDTH+1)+*(rawpt+WIDTH-1)+*(rawpt+WIDTH+1))/4)<<4);          /* R */
+            } else
+            {
+               /* bottom line or left column */
+   
+               *scanpt++ = ((*(rawpt))<<4); /* B */
+               *scanpt++ = (((*(rawpt+1)+*(rawpt-WIDTH))/2)<<4);      /* G */
+               *scanpt++ = ((*(rawpt-WIDTH+1))<<4);          /* R */
+            }
+         } else
+         { //odd pixel - Green
+            if ( i < (WIDTH*(HEIGHT-1)) && ((i % WIDTH) < (WIDTH-1)) )
+            {
+               *scanpt++ = (((*(rawpt-1)+*(rawpt+1))/2)<<4); /* B */
+               *scanpt++ = ((*(rawpt))<<4);      /* G */
+               *scanpt++ = (((*(rawpt-WIDTH)+*(rawpt+WIDTH))/2)<<4);  /* R */
+            } else
+            {
+               /* bottom line or right column */
+   
+               *scanpt++ = (((*(rawpt-1)))<<4); /* B */
+               *scanpt++ = ((*(rawpt))<<4);      /* G */
+               *scanpt++ = (((*(rawpt-WIDTH)))<<4);  /* R */
+            }
+         }
+      }
+      rawpt++;
+   }
+}
+
+/* Y12 to RGB24
+ * Convert from y12 to y16 by shifting the 12 bytes up.
+ */
+void y12_to_y16(long int WIDTH, long int HEIGHT, unsigned char *src, unsigned char *dst)
+{
+   long int i;
+   unsigned short *rawpt;
+   unsigned short *scanpt;
+   long int size;
+   
+   rawpt = (unsigned short *)src;
+   scanpt = (unsigned short *)dst;
+   size = WIDTH*HEIGHT;
+   
+   for(i=0; i < size; i++)
+   {
+      *scanpt++ = ((*rawpt++) << 4);
+   }
+}
+
+
+#define CLAMP(x)        ((x)<0?0:((x)>255)?255:(x))
+
+typedef struct {
+  int is_abs;
+  int len;
+  int val;
+} code_table_t;
+
+
+/* local storage */
 static code_table_t table[256];
 static int init_done = 0;
 
@@ -2072,447 +1889,318 @@
 
 static IplImage* icvRetrieveFrameCAM_V4L( CvCaptureCAM_V4L* capture, int) {
 
-#ifdef HAVE_CAMV4L2
-  if (V4L2_SUPPORT == 0)
-#endif /* HAVE_CAMV4L2 */
-  {
-
-    /* [FD] this really belongs here */
-    if (ioctl(capture->deviceHandle, VIDIOCSYNC, &capture->mmaps[capture->bufferIndex].frame) == -1) {
-      fprintf( stderr, "HIGHGUI ERROR: V4L: Could not SYNC to video stream. %s\n", strerror(errno));
-    }
-
-  }
-
    /* Now get what has already been captured as a IplImage return */
 
    /* First, reallocate imageData if the frame size changed */
-
-#ifdef HAVE_CAMV4L2
-
-  if (V4L2_SUPPORT == 1)
-  {
-
-    if(((unsigned long)capture->frame.width != capture->form.fmt.pix.width)
-       || ((unsigned long)capture->frame.height != capture->form.fmt.pix.height)) {
-        cvFree(&capture->frame.imageData);
-        cvInitImageHeader( &capture->frame,
-              cvSize( capture->form.fmt.pix.width,
-                  capture->form.fmt.pix.height ),
-              IPL_DEPTH_8U, 3, IPL_ORIGIN_TL, 4 );
-       capture->frame.imageData = (char *)cvAlloc(capture->frame.imageSize);
-    }
-
-  } else
-#endif /* HAVE_CAMV4L2 */
-  {
-
-    if((capture->frame.width != capture->mmaps[capture->bufferIndex].width)
-      || (capture->frame.height != capture->mmaps[capture->bufferIndex].height)) {
-       cvFree(&capture->frame.imageData);
-       cvInitImageHeader( &capture->frame,
-              cvSize( capture->captureWindow.width,
-                  capture->captureWindow.height ),
-              IPL_DEPTH_8U, 3, IPL_ORIGIN_TL, 4 );
-       capture->frame.imageData = (char *)cvAlloc(capture->frame.imageSize);
-    }
-
+  if(((unsigned long)capture->frame.width != capture->form.fmt.pix.width)
+     || ((unsigned long)capture->frame.height != capture->form.fmt.pix.height)) {
+      cvFree(&capture->frame.imageData);
+      switch(capture->palette)
+      {
+         case PALETTE_BGR24:
+         case PALETTE_YVU420:
+         case PALETTE_YUV411P:
+         case PALETTE_YUYV:
+         case PALETTE_UYVY:
+         case PALETTE_SBGGR8:
+         case PALETTE_SN9C10X:
+         case PALETTE_MJPEG:
+         case PALETTE_SGBRG:
+            cvInitImageHeader( &capture->frame,
+                     cvSize( capture->form.fmt.pix.width,
+                             capture->form.fmt.pix.height ),
+                     IPL_DEPTH_8U, 3, IPL_ORIGIN_TL, 4 );
+            /* Allocate space for RGBA data */
+            capture->frame.imageData = (char *)cvAlloc(capture->frame.imageSize);
+            break;
+         case PALETTE_SGRBG12:
+            cvInitImageHeader( &capture->frame,
+                     cvSize( capture->form.fmt.pix.width,
+                             capture->form.fmt.pix.height ),
+                     IPL_DEPTH_16U, 3, IPL_ORIGIN_TL, 4 );
+            /* Allocate space for RGBA data */
+            capture->frame.imageData = (char *)cvAlloc(capture->frame.imageSize);
+            break;
+         case PALETTE_Y12:
+            cvInitImageHeader( &capture->frame,
+                     cvSize( capture->form.fmt.pix.width,
+                             capture->form.fmt.pix.height ),
+                     IPL_DEPTH_16U, 1, IPL_ORIGIN_TL, 4 );
+            /* Allocate space for 16 bit Y data */
+            capture->frame.imageData = (char *)cvAlloc(capture->frame.imageSize);
+            break;
+      }
   }
 
-#ifdef HAVE_CAMV4L2
-
-  if (V4L2_SUPPORT == 1)
-  {
-    switch (capture->palette)
-      {
-      case PALETTE_BGR24:
-	memcpy((char *)capture->frame.imageData,
+  switch (capture->palette){
+    case PALETTE_BGR24:
+	    memcpy((char *)capture->frame.imageData,
 	       (char *)capture->buffers[capture->bufferIndex].start,
 	       capture->frame.imageSize);
-	break;
+	    break;
 
-      case PALETTE_YVU420:
-	  yuv420p_to_rgb24(capture->form.fmt.pix.width,
-			   capture->form.fmt.pix.height,
-			   (unsigned char*)(capture->buffers[capture->bufferIndex].start),
-			   (unsigned char*)capture->frame.imageData);
-	  break;
+  case PALETTE_YVU420:
+    yuv420p_to_rgb24(capture->form.fmt.pix.width,
+         capture->form.fmt.pix.height,
+         (unsigned char*)(capture->buffers[capture->bufferIndex].start),
+         (unsigned char*)capture->frame.imageData);
+    break;
+
+  case PALETTE_YUV411P:
+    yuv411p_to_rgb24(capture->form.fmt.pix.width,
+      capture->form.fmt.pix.height,
+      (unsigned char*)(capture->buffers[capture->bufferIndex].start),
+      (unsigned char*)capture->frame.imageData);
+    break;
 
-      case PALETTE_YUV411P:
-	yuv411p_to_rgb24(capture->form.fmt.pix.width,
-			 capture->form.fmt.pix.height,
-			 (unsigned char*)(capture->buffers[capture->bufferIndex].start),
-			 (unsigned char*)capture->frame.imageData);
-	break;
 #ifdef HAVE_JPEG
 #ifdef __USE_GNU
     /* support for MJPEG is only available with libjpeg and gcc,
        because it's use libjepg and fmemopen()
     */
-      case PALETTE_MJPEG:
-	if (!mjpeg_to_rgb24(capture->form.fmt.pix.width,
-			    capture->form.fmt.pix.height,
-			    (unsigned char*)(capture->buffers[capture->bufferIndex]
-					     .start),
-			    capture->buffers[capture->bufferIndex].length,
-			    (unsigned char*)capture->frame.imageData))
-	  return 0;
-	break;
+  case PALETTE_MJPEG:
+    if (!mjpeg_to_rgb24(capture->form.fmt.pix.width,capture->form.fmt.pix.height,
+          (unsigned char*)(capture->buffers[capture->bufferIndex].start),
+          capture->buffers[capture->bufferIndex].length,
+          (unsigned char*)capture->frame.imageData))
+      return 0;
+    break;
 #endif
 #endif
 
       case PALETTE_YUYV:
-	yuyv_to_rgb24(capture->form.fmt.pix.width,
-		      capture->form.fmt.pix.height,
-		      (unsigned char*)(capture->buffers[capture->bufferIndex].start),
-		      (unsigned char*)capture->frame.imageData);
-	break;
+  yuyv_to_rgb24(capture->form.fmt.pix.width,
+          capture->form.fmt.pix.height,
+          (unsigned char*)(capture->buffers[capture->bufferIndex].start),
+          (unsigned char*)capture->frame.imageData);
+  break;
 
       case PALETTE_UYVY:
-	uyvy_to_rgb24(capture->form.fmt.pix.width,
-		      capture->form.fmt.pix.height,
-		      (unsigned char*)(capture->buffers[capture->bufferIndex].start),
-		      (unsigned char*)capture->frame.imageData);
-	break;
-      case PALETTE_SBGGR8:
-	bayer2rgb24(capture->form.fmt.pix.width,
-		    capture->form.fmt.pix.height,
-		    (unsigned char*)capture->buffers[capture->bufferIndex].start,
-		    (unsigned char*)capture->frame.imageData);
-	break;
-
-      case PALETTE_SN9C10X:	
-	sonix_decompress_init();
-	sonix_decompress(capture->form.fmt.pix.width,
-			 capture->form.fmt.pix.height,
-			 (unsigned char*)capture->buffers[capture->bufferIndex].start,
-			 (unsigned char*)capture->buffers[(capture->bufferIndex+1) % capture->req.count].start);
-	
-	bayer2rgb24(capture->form.fmt.pix.width,
-		    capture->form.fmt.pix.height,
-		    (unsigned char*)capture->buffers[(capture->bufferIndex+1) % capture->req.count].start,
-		    (unsigned char*)capture->frame.imageData);
-	break;
-	
-      case PALETTE_SGBRG:	
-	sgbrg2rgb24(capture->form.fmt.pix.width,
-		    capture->form.fmt.pix.height,
-		    (unsigned char*)capture->buffers[(capture->bufferIndex+1) % capture->req.count].start,
-		    (unsigned char*)capture->frame.imageData);
-	break;
-      }
-  } else
-#endif /* HAVE_CAMV4L2 */
-  {
-    
-    switch(capture->imageProperties.palette) {
-      case VIDEO_PALETTE_RGB24:
-        memcpy((char *)capture->frame.imageData,
-           (char *)(capture->memoryMap + capture->memoryBuffer.offsets[capture->bufferIndex]),
-           capture->frame.imageSize);
-        break;
-      case VIDEO_PALETTE_YUV420P:
-        yuv420p_to_rgb24(capture->captureWindow.width,
-             capture->captureWindow.height,
-             (unsigned char*)(capture->memoryMap + capture->memoryBuffer.offsets[capture->bufferIndex]),
-             (unsigned char*)capture->frame.imageData);
-        break;
-      case VIDEO_PALETTE_YUV420:
-        yuv420_to_rgb24(capture->captureWindow.width,
-          capture->captureWindow.height,
-          (unsigned char*)(capture->memoryMap + capture->memoryBuffer.offsets[capture->bufferIndex]),
-          (unsigned char*)capture->frame.imageData);
-        break;
-      case VIDEO_PALETTE_YUV411P:
-        yuv411p_to_rgb24(capture->captureWindow.width,
-          capture->captureWindow.height,
-          (unsigned char*)(capture->memoryMap + capture->memoryBuffer.offsets[capture->bufferIndex]),
+  uyvy_to_rgb24(capture->form.fmt.pix.width,
+          capture->form.fmt.pix.height,
+          (unsigned char*)(capture->buffers[capture->bufferIndex].start),
           (unsigned char*)capture->frame.imageData);
-        break;
+  break;
+      case PALETTE_SBGGR8:
+  bayer2rgb24(capture->form.fmt.pix.width,
+        capture->form.fmt.pix.height,
+        (unsigned char*)capture->buffers[capture->bufferIndex].start,
+        (unsigned char*)capture->frame.imageData);
+  break;
+
+      case PALETTE_SN9C10X: 
+  sonix_decompress_init();
+  sonix_decompress(capture->form.fmt.pix.width,
+       capture->form.fmt.pix.height,
+       (unsigned char*)capture->buffers[capture->bufferIndex].start,
+       (unsigned char*)capture->buffers[(capture->bufferIndex+1) % capture->req.count].start);
+  
+  bayer2rgb24(capture->form.fmt.pix.width,
+        capture->form.fmt.pix.height,
+        (unsigned char*)capture->buffers[(capture->bufferIndex+1) % capture->req.count].start,
+        (unsigned char*)capture->frame.imageData);
+  break;
+  
+      case PALETTE_SGBRG: 
+  sgbrg2rgb24(capture->form.fmt.pix.width,
+        capture->form.fmt.pix.height,
+        (unsigned char*)capture->buffers[(capture->bufferIndex+1) % capture->req.count].start,
+        (unsigned char*)capture->frame.imageData);
+  break;
+      case PALETTE_SGRBG12: 
+         sgrbg12_to_rgb48(capture->form.fmt.pix.width, capture->form.fmt.pix.height,
+              (unsigned char*)capture->buffers[capture->bufferIndex].start,
+              (unsigned char*)capture->frame.imageData);
+      break;
+      case PALETTE_Y12: 
+         /* Converting the 12bit data to 16bit data before sending it out (up shifting) */
+         y12_to_y16(capture->form.fmt.pix.width, capture->form.fmt.pix.height,
+              (unsigned char*)capture->buffers[capture->bufferIndex].start,
+              (unsigned char*)capture->frame.imageData);
+      break;
       default:
-        fprintf( stderr,
-                 "HIGHGUI ERROR: V4L: Cannot convert from palette %d to RGB\n",
-                 capture->imageProperties.palette);
-
-        return 0;
-    }
-
+         fprintf(stderr, "HIGHGUI ERROR: V4L2: invalid capture format.\n");
+         return(0); // Return an invalid pointer
+      break;
   }
-
-   return(&capture->frame);
+  return(&capture->frame);
 }
 
 static double icvGetPropertyCAM_V4L (CvCaptureCAM_V4L* capture,
                                      int property_id ) {
 
-#ifdef HAVE_CAMV4L2
+  /* default value for min and max */
+  int v4l2_min = 0;
+  int v4l2_max = 255;
 
-  if (V4L2_SUPPORT == 1)
-  {
-
-      /* default value for min and max */
-      int v4l2_min = 0;
-      int v4l2_max = 255;
-
-      CLEAR (capture->form);
-      capture->form.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-      if (-1 == xioctl (capture->deviceHandle, VIDIOC_G_FMT, &capture->form)) {
-          /* display an error message, and return an error code */
-          perror ("VIDIOC_G_FMT");
-          return -1;
-      }
+  CLEAR (capture->form);
+  capture->form.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+  if (-1 == xioctl (capture->deviceHandle, VIDIOC_G_FMT, &capture->form)) {
+      /* display an error message, and return an error code */
+      perror ("VIDIOC_G_FMT");
+      return -1;
+  }
 
-      switch (property_id) {
-      case CV_CAP_PROP_FRAME_WIDTH:
-          return capture->form.fmt.pix.width;
-      case CV_CAP_PROP_FRAME_HEIGHT:
-          return capture->form.fmt.pix.height;
-      }
+  switch (property_id) {
+  case CV_CAP_PROP_FRAME_WIDTH:
+      // Do not complete ioctl, just return the value
+      return capture->form.fmt.pix.width;
+      break;
+  case CV_CAP_PROP_FRAME_HEIGHT:
+      // Do not complete ioctl, just return the value
+      return capture->form.fmt.pix.height;
+      break;
+  case CV_CAP_PROP_BRIGHTNESS:
+      capture->control.id = V4L2_CID_BRIGHTNESS;
+      break;
+  case CV_CAP_PROP_CONTRAST:
+      capture->control.id = V4L2_CID_CONTRAST;
+      break;
+  case CV_CAP_PROP_SATURATION:
+      capture->control.id = V4L2_CID_SATURATION;
+      break;
+  case CV_CAP_PROP_HUE:
+      capture->control.id = V4L2_CID_HUE;
+      break;
+  case CV_CAP_PROP_GAIN:
+      capture->control.id = V4L2_CID_GAIN;
+      break;
+  case CV_CAP_PROP_EXPOSURE:
+      capture->control.id = V4L2_CID_EXPOSURE;
+      break;
+  default:
+    fprintf(stderr,
+            "HIGHGUI ERROR: V4L2: getting property #%d is not supported\n",
+            property_id);
+    return -1;
+  }
 
-      /* initialize the control structure */
+  if (-1 == xioctl (capture->deviceHandle, VIDIOC_G_CTRL,
+                    &capture->control)) {
 
+      fprintf( stderr, "HIGHGUI ERROR: V4L2: ");
       switch (property_id) {
       case CV_CAP_PROP_BRIGHTNESS:
-          capture->control.id = V4L2_CID_BRIGHTNESS;
+          fprintf (stderr, "Brightness");
           break;
       case CV_CAP_PROP_CONTRAST:
-          capture->control.id = V4L2_CID_CONTRAST;
+          fprintf (stderr, "Contrast");
           break;
       case CV_CAP_PROP_SATURATION:
-          capture->control.id = V4L2_CID_SATURATION;
+          fprintf (stderr, "Saturation");
           break;
       case CV_CAP_PROP_HUE:
-          capture->control.id = V4L2_CID_HUE;
+          fprintf (stderr, "Hue");
           break;
       case CV_CAP_PROP_GAIN:
-          capture->control.id = V4L2_CID_GAIN;
+          fprintf (stderr, "Gain");
           break;
       case CV_CAP_PROP_EXPOSURE:
-          capture->control.id = V4L2_CID_EXPOSURE;
+          fprintf (stderr, "Exposure");
           break;
       default:
-        fprintf(stderr,
-                "HIGHGUI ERROR: V4L2: getting property #%d is not supported\n",
-                property_id);
-        return -1;
-      }
-
-      if (-1 == xioctl (capture->deviceHandle, VIDIOC_G_CTRL,
-                        &capture->control)) {
-
-          fprintf( stderr, "HIGHGUI ERROR: V4L2: ");
-          switch (property_id) {
-          case CV_CAP_PROP_BRIGHTNESS:
-              fprintf (stderr, "Brightness");
-              break;
-          case CV_CAP_PROP_CONTRAST:
-              fprintf (stderr, "Contrast");
-              break;
-          case CV_CAP_PROP_SATURATION:
-              fprintf (stderr, "Saturation");
-              break;
-          case CV_CAP_PROP_HUE:
-              fprintf (stderr, "Hue");
-              break;
-          case CV_CAP_PROP_GAIN:
-              fprintf (stderr, "Gain");
-              break;
-          case CV_CAP_PROP_EXPOSURE:
-              fprintf (stderr, "Exposure");
-              break;
-          }
-          fprintf (stderr, " is not supported by your device\n");
-
-          return -1;
-      }
-
-      /* get the min/max values */
-      switch (property_id) {
-
-      case CV_CAP_PROP_BRIGHTNESS:
-          v4l2_min = capture->v4l2_brightness_min;
-          v4l2_max = capture->v4l2_brightness_max;
-          break;
-      case CV_CAP_PROP_CONTRAST:
-          v4l2_min = capture->v4l2_contrast_min;
-          v4l2_max = capture->v4l2_contrast_max;
-          break;
-      case CV_CAP_PROP_SATURATION:
-          v4l2_min = capture->v4l2_saturation_min;
-          v4l2_max = capture->v4l2_saturation_max;
-          break;
-      case CV_CAP_PROP_HUE:
-          v4l2_min = capture->v4l2_hue_min;
-          v4l2_max = capture->v4l2_hue_max;
-          break;
-      case CV_CAP_PROP_GAIN:
-          v4l2_min = capture->v4l2_gain_min;
-          v4l2_max = capture->v4l2_gain_max;
-          break;
-      case CV_CAP_PROP_EXPOSURE:
-          v4l2_min = capture->v4l2_exposure_min;
-          v4l2_max = capture->v4l2_exposure_max;
+          fprintf (stderr, "Unknown property value");
           break;
       }
+      fprintf (stderr, " is not supported by your device\n");
 
-      /* all was OK, so convert to 0.0 - 1.0 range, and return the value */
-      return ((float)capture->control.value - v4l2_min + 1) / (v4l2_max - v4l2_min);
-
-  } else
-#endif /* HAVE_CAMV4L2 */
-  {
-
-    int retval = -1;
-
-    if (ioctl (capture->deviceHandle,
-               VIDIOCGWIN, &capture->captureWindow) < 0) {
-        fprintf (stderr,
-                 "HIGHGUI ERROR: V4L: "
-                 "Unable to determine size of incoming image\n");
-        icvCloseCAM_V4L(capture);
-        return -1;
-    }
-
-    switch (property_id) {
-    case CV_CAP_PROP_FRAME_WIDTH:
-        retval = capture->captureWindow.width;
-        break;
-    case CV_CAP_PROP_FRAME_HEIGHT:
-        retval = capture->captureWindow.height;
-        break;
-    case CV_CAP_PROP_BRIGHTNESS:
-        retval = capture->imageProperties.brightness;
-        break;
-    case CV_CAP_PROP_CONTRAST:
-        retval = capture->imageProperties.contrast;
-        break;
-    case CV_CAP_PROP_SATURATION:
-        retval = capture->imageProperties.colour;
-        break;
-    case CV_CAP_PROP_HUE:
-        retval = capture->imageProperties.hue;
-        break;
-    case CV_CAP_PROP_GAIN:
-        fprintf(stderr,
-                "HIGHGUI ERROR: V4L: Gain control in V4L is not supported\n");
-        return -1;
-        break;
-    case CV_CAP_PROP_EXPOSURE:
-        fprintf(stderr,
-                "HIGHGUI ERROR: V4L: Exposure control in V4L is not supported\n");
-        return -1;
-        break;
-    default:
-        fprintf(stderr,
-                "HIGHGUI ERROR: V4L: getting property #%d is not supported\n",
-                property_id);
-    }
-
-    if (retval == -1) {
-        /* there was a problem */
-        return -1;
-    }
+      return -1;
+  }
 
-    /* all was OK, so convert to 0.0 - 1.0 range, and return the value */
-    return float (retval) / 0xFFFF;
+  /* get the min/max values */
+  switch (property_id) {
 
+  case CV_CAP_PROP_BRIGHTNESS:
+      v4l2_min = capture->v4l2_brightness_min;
+      v4l2_max = capture->v4l2_brightness_max;
+      break;
+  case CV_CAP_PROP_CONTRAST:
+      v4l2_min = capture->v4l2_contrast_min;
+      v4l2_max = capture->v4l2_contrast_max;
+      break;
+  case CV_CAP_PROP_SATURATION:
+      v4l2_min = capture->v4l2_saturation_min;
+      v4l2_max = capture->v4l2_saturation_max;
+      break;
+  case CV_CAP_PROP_HUE:
+      v4l2_min = capture->v4l2_hue_min;
+      v4l2_max = capture->v4l2_hue_max;
+      break;
+  case CV_CAP_PROP_GAIN:
+      v4l2_min = capture->v4l2_gain_min;
+      v4l2_max = capture->v4l2_gain_max;
+      break;
+  case CV_CAP_PROP_EXPOSURE:
+      v4l2_min = capture->v4l2_exposure_min;
+      v4l2_max = capture->v4l2_exposure_max;
+      break;
+  default:
+      fprintf(stderr,
+            "HIGHGUI ERROR: V4L2: getting property #%d is not supported\n",
+            property_id);
+      return -1;
   }
 
-};
+  /* all was OK, so convert to 0.0 - 1.0 range, and return the value */
+  return ((float)capture->control.value - v4l2_min + 1) / (v4l2_max - v4l2_min);
+}
 
 static int icvSetVideoSize( CvCaptureCAM_V4L* capture, int w, int h) {
 
-#ifdef HAVE_CAMV4L2
-
-  if (V4L2_SUPPORT == 1)
-  {
-
-    CLEAR (capture->crop);
-    capture->crop.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-    capture->crop.c.left       = 0;
-    capture->crop.c.top        = 0;
-    capture->crop.c.height     = h*24;
-    capture->crop.c.width      = w*24;
-
-    /* set the crop area, but don't exit if the device don't support croping */
-    xioctl (capture->deviceHandle, VIDIOC_S_CROP, &capture->crop);
-
-    CLEAR (capture->form);
-    capture->form.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-
-    /* read the current setting, mainly to retreive the pixelformat information */
-    xioctl (capture->deviceHandle, VIDIOC_G_FMT, &capture->form);
-
-    /* set the values we want to change */
-    capture->form.fmt.pix.width = w;
-    capture->form.fmt.pix.height = h;
-    capture->form.fmt.win.chromakey = 0;
-    capture->form.fmt.win.field = V4L2_FIELD_ANY;
-    capture->form.fmt.win.clips = 0;
-    capture->form.fmt.win.clipcount = 0;
-    capture->form.fmt.pix.field = V4L2_FIELD_ANY;
-
-    /* ask the device to change the size
-     * don't test if the set of the size is ok, because some device
-     * don't allow changing the size, and we will get the real size
-     * later */
-    xioctl (capture->deviceHandle, VIDIOC_S_FMT, &capture->form);
-
-    /* try to set framerate to 30 fps */
-    struct v4l2_streamparm setfps;
-    memset (&setfps, 0, sizeof(struct v4l2_streamparm));
-    setfps.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-    setfps.parm.capture.timeperframe.numerator = 1;
-    setfps.parm.capture.timeperframe.denominator = 30;
-    xioctl (capture->deviceHandle, VIDIOC_S_PARM, &setfps);
-
-    /* we need to re-initialize some things, like buffers, because the size has
-     * changed */
-    capture->FirstCapture = 1;
-
-    /* Get window info again, to get the real value */
-    if (-1 == xioctl (capture->deviceHandle, VIDIOC_G_FMT, &capture->form))
-    {
-      fprintf(stderr, "HIGHGUI ERROR: V4L/V4L2: Could not obtain specifics of capture window.\n\n");
-
-      icvCloseCAM_V4L(capture);
-
-      return 0;
-    }
-
-    return 0;
-
-  } else
-#endif /* HAVE_CAMV4L2 */
-  {
-
-    if (capture==0) return 0;
-     if (w>capture->capability.maxwidth) {
-       w=capture->capability.maxwidth;
-     }
-     if (h>capture->capability.maxheight) {
-       h=capture->capability.maxheight;
-     }
-
-     capture->captureWindow.width=w;
-     capture->captureWindow.height=h;
-
-     if (ioctl(capture->deviceHandle, VIDIOCSWIN, &capture->captureWindow) < 0) {
-       icvCloseCAM_V4L(capture);
-       return 0;
-     }
-
-     if (ioctl(capture->deviceHandle, VIDIOCGWIN, &capture->captureWindow) < 0) {
-       icvCloseCAM_V4L(capture);
-       return 0;
-     }
-
-     capture->FirstCapture = 1;
-
+  CLEAR (capture->crop);
+  capture->crop.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+  capture->crop.c.left       = 0;
+  capture->crop.c.top        = 0;
+  capture->crop.c.height     = h*24;
+  capture->crop.c.width      = w*24;
+  
+  /* set the crop area, but don't exit if the device don't support croping */
+  xioctl (capture->deviceHandle, VIDIOC_S_CROP, &capture->crop);
+  
+  CLEAR (capture->form);
+  capture->form.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+  
+  /* read the current setting, mainly to retreive the pixelformat information */
+  xioctl (capture->deviceHandle, VIDIOC_G_FMT, &capture->form);
+  
+  /* set the values we want to change */
+  capture->form.fmt.pix.width = w;
+  capture->form.fmt.pix.height = h;
+  capture->form.fmt.win.chromakey = 0;
+  capture->form.fmt.win.field = V4L2_FIELD_ANY;
+  capture->form.fmt.win.clips = 0;
+  capture->form.fmt.win.clipcount = 0;
+  capture->form.fmt.pix.field = V4L2_FIELD_ANY;
+  
+  /* ask the device to change the size
+  * don't test if the set of the size is ok, because some device
+  * don't allow changing the size, and we will get the real size
+  * later */
+  xioctl (capture->deviceHandle, VIDIOC_S_FMT, &capture->form);
+  
+  /* try to set framerate to 30 fps */
+  struct v4l2_streamparm setfps;
+  memset (&setfps, 0, sizeof(struct v4l2_streamparm));
+  setfps.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+  setfps.parm.capture.timeperframe.numerator = 1;
+  setfps.parm.capture.timeperframe.denominator = 30;
+  xioctl (capture->deviceHandle, VIDIOC_S_PARM, &setfps);
+  
+  /* we need to re-initialize some things, like buffers, because the size has
+  * changed */
+  capture->FirstCapture = 1;
+  
+  /* Get window info again, to get the real value */
+  if (-1 == xioctl (capture->deviceHandle, VIDIOC_G_FMT, &capture->form))
+  {
+   fprintf(stderr, "HIGHGUI ERROR: V4L/V4L2: Could not obtain specifics of capture window.\n\n");
+  
+   icvCloseCAM_V4L(capture);
+  
+   return 0;
   }
 
   return 0;
-
 }
 
 static int icvSetControl (CvCaptureCAM_V4L* capture,
@@ -2525,167 +2213,116 @@
     value = 1.0;
   }
 
-#ifdef HAVE_CAMV4L2
-
-  if (V4L2_SUPPORT == 1)
-  {
-
-    /* default value for min and max */
-    int v4l2_min = 0;
-    int v4l2_max = 255;
+  /* default value for min and max */
+  int v4l2_min = 0;
+  int v4l2_max = 255;
 
-    /* initialisations */
-    CLEAR (capture->control);
+  /* initialisations */
+  CLEAR (capture->control);
 
-    /* set which control we want to set */
-    switch (property_id) {
+  /* set which control we want to set */
+  switch (property_id) {
 
-    case CV_CAP_PROP_BRIGHTNESS:
-        capture->control.id = V4L2_CID_BRIGHTNESS;
-        break;
-    case CV_CAP_PROP_CONTRAST:
-        capture->control.id = V4L2_CID_CONTRAST;
-        break;
-    case CV_CAP_PROP_SATURATION:
-        capture->control.id = V4L2_CID_SATURATION;
-        break;
-    case CV_CAP_PROP_HUE:
-        capture->control.id = V4L2_CID_HUE;
-        break;
-    case CV_CAP_PROP_GAIN:
-        capture->control.id = V4L2_CID_GAIN;
-        break;
-    case CV_CAP_PROP_EXPOSURE:
-        capture->control.id = V4L2_CID_EXPOSURE;
-        break;
-    default:
-        fprintf(stderr,
-                "HIGHGUI ERROR: V4L2: setting property #%d is not supported\n",
-                property_id);
-        return -1;
-    }
+  case CV_CAP_PROP_BRIGHTNESS:
+      capture->control.id = V4L2_CID_BRIGHTNESS;
+      break;
+  case CV_CAP_PROP_CONTRAST:
+      capture->control.id = V4L2_CID_CONTRAST;
+      break;
+  case CV_CAP_PROP_SATURATION:
+      capture->control.id = V4L2_CID_SATURATION;
+      break;
+  case CV_CAP_PROP_HUE:
+      capture->control.id = V4L2_CID_HUE;
+      break;
+  case CV_CAP_PROP_GAIN:
+      capture->control.id = V4L2_CID_GAIN;
+      break;
+  case CV_CAP_PROP_EXPOSURE:
+      capture->control.id = V4L2_CID_EXPOSURE;
+      break;
+  default:
+      fprintf(stderr,
+              "HIGHGUI ERROR: V4L2: setting property #%d is not supported\n",
+              property_id);
+      return -1;
+  }
 
-    /* get the min and max values */
-    if (-1 == xioctl (capture->deviceHandle,
-                      VIDIOC_G_CTRL, &capture->control)) {
+  /* get the min and max values */
+  if (-1 == xioctl (capture->deviceHandle,
+                    VIDIOC_G_CTRL, &capture->control)) {
 //          perror ("VIDIOC_G_CTRL for getting min/max values");
-          return -1;
-    }
-
-    /* get the min/max values */
-    switch (property_id) {
-
-    case CV_CAP_PROP_BRIGHTNESS:
-        v4l2_min = capture->v4l2_brightness_min;
-        v4l2_max = capture->v4l2_brightness_max;
-        break;
-    case CV_CAP_PROP_CONTRAST:
-        v4l2_min = capture->v4l2_contrast_min;
-        v4l2_max = capture->v4l2_contrast_max;
-        break;
-    case CV_CAP_PROP_SATURATION:
-        v4l2_min = capture->v4l2_saturation_min;
-        v4l2_max = capture->v4l2_saturation_max;
-        break;
-    case CV_CAP_PROP_HUE:
-        v4l2_min = capture->v4l2_hue_min;
-        v4l2_max = capture->v4l2_hue_max;
-        break;
-    case CV_CAP_PROP_GAIN:
-        v4l2_min = capture->v4l2_gain_min;
-        v4l2_max = capture->v4l2_gain_max;
-        break;
-    case CV_CAP_PROP_EXPOSURE:
-        v4l2_min = capture->v4l2_exposure_min;
-        v4l2_max = capture->v4l2_exposure_max;
-        break;
-    }
-
-    /* initialisations */
-    CLEAR (capture->control);
-
-    /* set which control we want to set */
-    switch (property_id) {
-
-    case CV_CAP_PROP_BRIGHTNESS:
-        capture->control.id = V4L2_CID_BRIGHTNESS;
-        break;
-    case CV_CAP_PROP_CONTRAST:
-        capture->control.id = V4L2_CID_CONTRAST;
-        break;
-    case CV_CAP_PROP_SATURATION:
-        capture->control.id = V4L2_CID_SATURATION;
-        break;
-    case CV_CAP_PROP_HUE:
-        capture->control.id = V4L2_CID_HUE;
-        break;
-    case CV_CAP_PROP_GAIN:
-        capture->control.id = V4L2_CID_GAIN;
-        break;
-    case CV_CAP_PROP_EXPOSURE:
-        capture->control.id = V4L2_CID_EXPOSURE;
-        break;
-    default:
-        fprintf(stderr,
-                "HIGHGUI ERROR: V4L2: setting property #%d is not supported\n",
-                property_id);
         return -1;
-    }
+  }
 
-    /* set the value we want to set to the scaled the value */
-    capture->control.value = (int)(value * (v4l2_max - v4l2_min) + v4l2_min);
+  /* get the min/max values */
+  switch (property_id) {
 
-    /* The driver may clamp the value or return ERANGE, ignored here */
-    if (-1 == xioctl (capture->deviceHandle,
-                      VIDIOC_S_CTRL, &capture->control) && errno != ERANGE) {
-        perror ("VIDIOC_S_CTRL");
-        return -1;
-    }
-  } else
-#endif /* HAVE_CAMV4L2 */
-  {
+  case CV_CAP_PROP_BRIGHTNESS:
+      v4l2_min = capture->v4l2_brightness_min;
+      v4l2_max = capture->v4l2_brightness_max;
+      break;
+  case CV_CAP_PROP_CONTRAST:
+      v4l2_min = capture->v4l2_contrast_min;
+      v4l2_max = capture->v4l2_contrast_max;
+      break;
+  case CV_CAP_PROP_SATURATION:
+      v4l2_min = capture->v4l2_saturation_min;
+      v4l2_max = capture->v4l2_saturation_max;
+      break;
+  case CV_CAP_PROP_HUE:
+      v4l2_min = capture->v4l2_hue_min;
+      v4l2_max = capture->v4l2_hue_max;
+      break;
+  case CV_CAP_PROP_GAIN:
+      v4l2_min = capture->v4l2_gain_min;
+      v4l2_max = capture->v4l2_gain_max;
+      break;
+  case CV_CAP_PROP_EXPOSURE:
+      v4l2_min = capture->v4l2_exposure_min;
+      v4l2_max = capture->v4l2_exposure_max;
+      break;
+  }
 
-    int v4l_value;
+  /* initialisations */
+  CLEAR (capture->control);
 
-    /* scale the value to the wanted integer one */
-    v4l_value = (int)(0xFFFF * value);
+  /* set which control we want to set */
+  switch (property_id) {
 
-    switch (property_id) {
-    case CV_CAP_PROP_BRIGHTNESS:
-      capture->imageProperties.brightness = v4l_value;
+  case CV_CAP_PROP_BRIGHTNESS:
+      capture->control.id = V4L2_CID_BRIGHTNESS;
       break;
-    case CV_CAP_PROP_CONTRAST:
-      capture->imageProperties.contrast = v4l_value;
+  case CV_CAP_PROP_CONTRAST:
+      capture->control.id = V4L2_CID_CONTRAST;
       break;
-    case CV_CAP_PROP_SATURATION:
-      capture->imageProperties.colour = v4l_value;
+  case CV_CAP_PROP_SATURATION:
+      capture->control.id = V4L2_CID_SATURATION;
       break;
-    case CV_CAP_PROP_HUE:
-      capture->imageProperties.hue = v4l_value;
+  case CV_CAP_PROP_HUE:
+      capture->control.id = V4L2_CID_HUE;
       break;
-    case CV_CAP_PROP_GAIN:
-        fprintf(stderr,
-                "HIGHGUI ERROR: V4L: Gain control in V4L is not supported\n");
-        return -1;
-    case CV_CAP_PROP_EXPOSURE:
-        fprintf(stderr,
-                "HIGHGUI ERROR: V4L: Exposure control in V4L is not supported\n");
-        return -1;
-    default:
-        fprintf(stderr,
-                "HIGHGUI ERROR: V4L: property #%d is not supported\n",
-                property_id);
-        return -1;
-    }
+  case CV_CAP_PROP_GAIN:
+      capture->control.id = V4L2_CID_GAIN;
+      break;
+  case CV_CAP_PROP_EXPOSURE:
+      capture->control.id = V4L2_CID_EXPOSURE;
+      break;
+  default:
+      fprintf(stderr,
+              "HIGHGUI ERROR: V4L2: setting property #%d is not supported\n",
+              property_id);
+      return -1;
+  }
 
-    if (ioctl(capture->deviceHandle, VIDIOCSPICT, &capture->imageProperties)
-        < 0)
-    {
-       fprintf(stderr,
-               "HIGHGUI ERROR: V4L: Unable to set video informations\n");
-       icvCloseCAM_V4L(capture);
-       return -1;
-    }
+  /* set the value we want to set to the scaled the value */
+  capture->control.value = (int)(value * (v4l2_max - v4l2_min) + v4l2_min);
+
+  /* The driver may clamp the value or return ERANGE, ignored here */
+  if (-1 == xioctl (capture->deviceHandle,
+                    VIDIOC_S_CTRL, &capture->control) && errno != ERANGE) {
+      perror ("VIDIOC_S_CTRL");
+      return -1;
   }
 
   /* all was OK */
@@ -2744,44 +2381,23 @@
    if (capture)
    {
 
-#ifdef HAVE_CAMV4L2
-     if (V4L2_SUPPORT == 0)
-#endif /* HAVE_CAMV4L2 */
-     {
-
-       if (capture->mmaps)
-         free(capture->mmaps);
-       if (capture->memoryMap)
-         munmap(capture->memoryMap, capture->memoryBuffer.size);
-
+     capture->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+     if (ioctl(capture->deviceHandle, VIDIOC_STREAMOFF, &capture->type) < 0) {
+         perror ("Unable to stop the stream.");
      }
-#ifdef HAVE_CAMV4L2
-     else {
-       capture->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-       if (ioctl(capture->deviceHandle, VIDIOC_STREAMOFF, &capture->type) < 0) {
-           perror ("Unable to stop the stream.");
-       }
 
-       for (unsigned int n_buffers = 0; n_buffers < capture->req.count; ++n_buffers)
-       {
-           if (-1 == munmap (capture->buffers[n_buffers].start, capture->buffers[n_buffers].length)) {
-               perror ("munmap");
-           }
-       }
-
-       if (capture->buffers[MAX_V4L_BUFFERS].start)
-       {
-    	   free(capture->buffers[MAX_V4L_BUFFERS].start);
-    	   capture->buffers[MAX_V4L_BUFFERS].start = 0;
-       }
+     for (unsigned int n_buffers = 0; n_buffers < capture->req.count; ++n_buffers)
+     {
+         if (-1 == munmap (capture->buffers[n_buffers].start, capture->buffers[n_buffers].length)) {
+             perror ("munmap");
+         }
      }
-#endif /* HAVE_CAMV4L2 */
 
      if (capture->deviceHandle != -1)
        close(capture->deviceHandle);
 
-     if (capture->frame.imageData) cvFree(&capture->frame.imageData);
-      //cvFree((void **)capture);
+     if (capture->frame.imageData) 
+         cvFree(&capture->frame.imageData);
    }
 };
 
